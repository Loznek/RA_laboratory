{"version":3,"sources":["../src/index.ts","../src/buildApolloClient.ts","../src/constants.ts","../src/introspection.ts"],"sourcesContent":["import merge from 'lodash/merge';\nimport get from 'lodash/get';\nimport pluralize from 'pluralize';\nimport {\n    DataProvider,\n    HttpError,\n    GET_LIST,\n    GET_ONE,\n    GET_MANY,\n    GET_MANY_REFERENCE,\n    CREATE,\n    UPDATE,\n    DELETE,\n    DELETE_MANY,\n    UPDATE_MANY,\n} from 'ra-core';\nimport {\n    ApolloClient,\n    ApolloClientOptions,\n    ApolloError,\n    ApolloQueryResult,\n    MutationOptions,\n    WatchQueryOptions,\n    QueryOptions,\n    OperationVariables,\n    ServerError,\n} from '@apollo/client';\n\nimport buildApolloClient from './buildApolloClient';\nimport {\n    QUERY_TYPES as INNER_QUERY_TYPES,\n    MUTATION_TYPES as INNER_MUTATION_TYPES,\n    ALL_TYPES as INNER_ALL_TYPES,\n} from './constants';\nimport {\n    introspectSchema,\n    IntrospectionOptions,\n    IntrospectionResult,\n} from './introspection';\n\nexport * from './introspection';\nexport const QUERY_TYPES = INNER_QUERY_TYPES;\nexport const MUTATION_TYPES = INNER_MUTATION_TYPES;\nexport const ALL_TYPES = INNER_ALL_TYPES;\n\nconst RaFetchMethodMap = {\n    getList: GET_LIST,\n    getMany: GET_MANY,\n    getManyReference: GET_MANY_REFERENCE,\n    getOne: GET_ONE,\n    create: CREATE,\n    delete: DELETE,\n    deleteMany: DELETE_MANY,\n    update: UPDATE,\n    updateMany: UPDATE_MANY,\n};\nconst defaultOptions = {\n    resolveIntrospection: introspectSchema,\n    introspection: {\n        operationNames: {\n            [GET_LIST]: resource => `all${pluralize(resource.name)}`,\n            [GET_ONE]: resource => `${resource.name}`,\n            [GET_MANY]: resource => `all${pluralize(resource.name)}`,\n            [GET_MANY_REFERENCE]: resource => `all${pluralize(resource.name)}`,\n            [CREATE]: resource => `create${resource.name}`,\n            [UPDATE]: resource => `update${resource.name}`,\n            [DELETE]: resource => `delete${resource.name}`,\n        },\n        exclude: undefined,\n        include: undefined,\n    },\n};\n\nconst getOptions = (\n    options: GetQueryOptions | GetMutationOptions | GetWatchQueryOptions,\n    raFetchMethod: string,\n    resource: string\n) => {\n    if (typeof options === 'function') {\n        return options(resource, raFetchMethod);\n    }\n\n    return options;\n};\n\nexport type BuildQueryResult = QueryOptions<OperationVariables, any> & {\n    parseResponse: (response: ApolloQueryResult<any>) => any;\n};\n\nexport type BuildQuery = (\n    name: string,\n    resource: string,\n    params: any\n) => BuildQueryResult;\n\nexport type BuildQueryFactory = (\n    introspectionResults: IntrospectionResult\n) => BuildQuery;\n\nexport type GetQueryOptions = (\n    resource: string,\n    raFetchMethod: string\n) => Partial<QueryOptions<OperationVariables, any>>;\n\nexport type GetMutationOptions = (\n    resource: string,\n    raFetchMethod: string\n) => Partial<MutationOptions<OperationVariables, any>>;\n\nexport type GetWatchQueryOptions = (\n    resource: string,\n    raFetchMethod: string\n) => Partial<WatchQueryOptions<OperationVariables, any>>;\n\nexport type Options = {\n    client?: ApolloClient<unknown>;\n    clientOptions?: Partial<ApolloClientOptions<unknown>>;\n    introspection?: false | Partial<IntrospectionOptions>;\n    override?: {\n        [key: string]: (params: any) => BuildQueryResult;\n    };\n    buildQuery: BuildQueryFactory;\n    query?: GetQueryOptions;\n    mutation?: GetMutationOptions;\n    watchQuery?: GetWatchQueryOptions;\n};\n\nexport default async (options: Options): Promise<DataProvider> => {\n    const {\n        client: clientObject,\n        clientOptions,\n        introspection,\n        resolveIntrospection,\n        buildQuery: buildQueryFactory,\n        override = {},\n        ...otherOptions\n    } = merge({}, defaultOptions, options);\n\n    if (override && process.env.NODE_ENV === 'production') {\n        console.warn(\n            // eslint-disable-line\n            'The override option is deprecated. You should instead wrap the buildQuery function provided by the dataProvider you use.'\n        );\n    }\n\n    const client = clientObject || buildApolloClient(clientOptions);\n\n    let introspectionResults;\n\n    const raDataProvider = new Proxy<DataProvider>(defaultDataProvider, {\n        get: (target, name) => {\n            if (typeof name === 'symbol' || name === 'then') {\n                return;\n            }\n            const raFetchMethod = RaFetchMethodMap[name];\n            return async (resource, params) => {\n                if (introspection) {\n                    introspectionResults = await resolveIntrospection(\n                        client,\n                        introspection\n                    );\n                }\n\n                const buildQuery = buildQueryFactory(introspectionResults);\n                const overriddenBuildQuery = get(\n                    override,\n                    `${resource}.${raFetchMethod}`\n                );\n\n                const { parseResponse, ...query } = overriddenBuildQuery\n                    ? {\n                          ...buildQuery(raFetchMethod, resource, params),\n                          ...overriddenBuildQuery(params),\n                      }\n                    : buildQuery(raFetchMethod, resource, params);\n\n                const operation = getQueryOperation(query.query);\n\n                if (operation === 'query') {\n                    const apolloQuery = {\n                        ...query,\n                        fetchPolicy: 'network-only',\n                        ...getOptions(\n                            otherOptions.query,\n                            raFetchMethod,\n                            resource\n                        ),\n                    };\n\n                    return (\n                        client\n                            // @ts-ignore\n                            .query(apolloQuery)\n                            .then(response => parseResponse(response))\n                            .catch(handleError)\n                    );\n                }\n\n                const apolloQuery = {\n                    mutation: query.query,\n                    variables: query.variables,\n                    ...getOptions(\n                        otherOptions.mutation,\n                        raFetchMethod,\n                        resource\n                    ),\n                };\n\n                return (\n                    client\n                        // @ts-ignore\n                        .mutate(apolloQuery)\n                        .then(parseResponse)\n                        .catch(handleError)\n                );\n            };\n        },\n    });\n\n    return raDataProvider;\n};\n\nconst handleError = (error: ApolloError) => {\n    if (error?.networkError as ServerError) {\n        throw new HttpError(\n            (error?.networkError as ServerError)?.message,\n            (error?.networkError as ServerError)?.statusCode\n        );\n    }\n\n    throw new HttpError(error.message, 200, error);\n};\n\nconst getQueryOperation = query => {\n    if (query && query.definitions && query.definitions.length > 0) {\n        return query.definitions[0].operation;\n    }\n\n    throw new Error('Unable to determine the query operation');\n};\n\n// Only used to initialize proxy\nconst defaultDataProvider = {\n    create: () => Promise.resolve({ data: null }), // avoids adding a context in tests\n    delete: () => Promise.resolve({ data: null }), // avoids adding a context in tests\n    deleteMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n    getList: () => Promise.resolve({ data: [], total: 0 }), // avoids adding a context in tests\n    getMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n    getManyReference: () => Promise.resolve({ data: [], total: 0 }), // avoids adding a context in tests\n    getOne: () => Promise.resolve({ data: null }), // avoids adding a context in tests\n    update: () => Promise.resolve({ data: null }), // avoids adding a context in tests\n    updateMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n};\n","import {\n    ApolloClient,\n    ApolloClientOptions,\n    HttpLink,\n    InMemoryCache,\n} from '@apollo/client';\n\nexport default (options: Partial<ApolloClientOptions<unknown>>) => {\n    if (!options) {\n        return new ApolloClient({\n            cache: new InMemoryCache().restore({}),\n        });\n    }\n\n    const {\n        cache = new InMemoryCache().restore({}),\n        uri,\n        link = !!uri ? new HttpLink({ uri }) : undefined,\n        ...otherOptions\n    } = options;\n\n    return new ApolloClient({\n        link,\n        cache,\n        ...otherOptions,\n    });\n};\n","import {\n    GET_LIST,\n    GET_ONE,\n    GET_MANY,\n    GET_MANY_REFERENCE,\n    CREATE,\n    UPDATE,\n    UPDATE_MANY,\n    DELETE,\n    DELETE_MANY,\n} from 'ra-core';\n\nexport const QUERY_TYPES = [GET_LIST, GET_MANY, GET_MANY_REFERENCE, GET_ONE];\nexport const MUTATION_TYPES = [\n    CREATE,\n    UPDATE,\n    DELETE,\n    UPDATE_MANY,\n    DELETE_MANY,\n];\nexport const ALL_TYPES = QUERY_TYPES.concat(MUTATION_TYPES);\n","import {\n    getIntrospectionQuery,\n    IntrospectionObjectType,\n    IntrospectionQuery,\n    IntrospectionSchema,\n    IntrospectionType,\n} from 'graphql';\nimport { ApolloClient, gql } from '@apollo/client';\n\nimport { ALL_TYPES } from './constants';\n\nlet introspectionPromise;\n\n/**\n * @param {ApolloClient} client The Apollo client\n * @param {Object} options The introspection options\n */\nexport const introspectSchema = async (\n    client: ApolloClient<unknown>,\n    options: IntrospectionOptions\n) => {\n    if (introspectionPromise) {\n        return introspectionPromise;\n    }\n    introspectionPromise = runSchemaIntrospection(client, options);\n    return introspectionPromise;\n};\n\nexport type IntrospectionOptions = {\n    schema?: IntrospectionSchema;\n    operationNames: {\n        [key: string]: (type: IntrospectionType) => string;\n    };\n    exclude?: string[] | ((type: IntrospectionType) => boolean);\n    include?: string[] | ((type: IntrospectionType) => boolean);\n};\n\nexport type IntrospectedResource = {\n    type: IntrospectionObjectType;\n};\nexport type IntrospectionResult = {\n    types: IntrospectionType[];\n    queries: IntrospectionObjectType[];\n    resources: IntrospectedResource[];\n    schema: IntrospectionSchema;\n};\n\nconst runSchemaIntrospection = async (\n    client: ApolloClient<unknown>,\n    options: IntrospectionOptions\n) => {\n    const schema = options.schema ? options.schema : await fetchSchema(client);\n    const queries = getQueriesFromSchema(schema);\n    const types = getTypesFromSchema(schema);\n    const resources = getResources(types, queries, options);\n\n    return {\n        types,\n        queries,\n        resources,\n        schema,\n    };\n};\n\nconst fetchSchema = (\n    client: ApolloClient<unknown>\n): Promise<IntrospectionSchema> => {\n    return client\n        .query<IntrospectionQuery>({\n            fetchPolicy: 'network-only',\n            query: gql`\n                ${getIntrospectionQuery()}\n            `,\n        })\n        .then(({ data: { __schema } }) => __schema);\n};\n\nconst getQueriesFromSchema = (\n    schema: IntrospectionSchema\n): IntrospectionObjectType[] => {\n    return schema.types.reduce((acc, type) => {\n        if (\n            type.name !== schema.queryType?.name &&\n            type.name !== schema.mutationType?.name &&\n            (type as IntrospectionObjectType).fields\n        ) {\n            return acc;\n        }\n\n        return [...acc, ...((type as IntrospectionObjectType).fields || [])];\n    }, []);\n};\n\nconst getTypesFromSchema = (schema: IntrospectionSchema) => {\n    return schema.types.filter(\n        type =>\n            type.name !== (schema.queryType && schema.queryType.name) &&\n            type.name !== (schema.mutationType && schema.mutationType.name)\n    );\n};\n\nconst getResources = (\n    types: IntrospectionType[],\n    queries: IntrospectionObjectType[],\n    options: IntrospectionOptions\n): IntrospectedResource[] => {\n    const filteredResources = types.filter(type =>\n        isResource(type, queries, options)\n    );\n    return filteredResources.map(type =>\n        buildResource(type as IntrospectionObjectType, queries, options)\n    );\n};\n\nconst isResource = (\n    type: IntrospectionType,\n    queries: IntrospectionObjectType[],\n    options: IntrospectionOptions\n) => {\n    if (isResourceIncluded(type, options)) return true;\n    if (isResourceExcluded(type, options)) return false;\n\n    const operations = Object.keys(options.operationNames).map(operation =>\n        options.operationNames[operation](type)\n    );\n\n    const hasAtLeastOneOperation = operations.some(operation =>\n        queries.find(({ name }) => name === operation)\n    );\n\n    return hasAtLeastOneOperation;\n};\n\nexport const isResourceIncluded = (\n    type: IntrospectionType,\n    { include }: Partial<IntrospectionOptions> = {}\n) => {\n    if (Array.isArray(include)) {\n        return include.includes(type.name);\n    }\n\n    if (typeof include === 'function') {\n        return include(type);\n    }\n\n    return false;\n};\n\nexport const isResourceExcluded = (\n    type: IntrospectionType,\n    { exclude }: Partial<IntrospectionOptions> = {}\n) => {\n    if (Array.isArray(exclude)) {\n        return exclude.includes(type.name);\n    }\n\n    if (typeof exclude === 'function') {\n        return exclude(type);\n    }\n\n    return false;\n};\n\nconst buildResource = (\n    type: IntrospectionObjectType,\n    queries: IntrospectionObjectType[],\n    options: IntrospectionOptions\n): IntrospectedResource => {\n    return ALL_TYPES.reduce(\n        (acc, raFetchMethod) => {\n            const query = queries.find(\n                ({ name }) =>\n                    options.operationNames[raFetchMethod] &&\n                    name === options.operationNames[raFetchMethod](type)\n            );\n\n            if (!query) return acc;\n\n            return {\n                ...acc,\n                [raFetchMethod]: query,\n            };\n        },\n        { type }\n    );\n};\n"],"mappings":"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","names":[]}